<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebXR Plane Sensing</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/webxr-polyfill@latest/build/webxr-polyfill.min.js"></script>
</head>
<body style="margin: 0; overflow: hidden;">
    <div id="info" style="position: absolute; top: 10px; left: 10px; z-index: 10; color: white;"></div>

    <script>
        // Подключаем WebXR Polyfill
        const polyfill = new WebXRPolyfill();

        // Основная сцена Three.js
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );

        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Создаём свет
        const light = new THREE.PointLight(0xffffff, 1, 100);
        light.position.set(5, 5, 5);
        scene.add(light);

        // Плоскости
        const planes = [];
        for (let i = 0; i < 5; i++) {
            const geometry = new THREE.PlaneGeometry(1, 1);
            const material = new THREE.MeshBasicMaterial({
                color: Math.random() * 0xffffff,
                side: THREE.DoubleSide,
            });
            const plane = new THREE.Mesh(geometry, material);
            plane.position.set(Math.random() * 4 - 2, Math.random() * 4 - 2, -Math.random() * 4);
            planes.push(plane);
            scene.add(plane);
        }

        // Обновление плоскостей с данными сенсоров
        function updatePlanesWithSensors(event) {
            const { alpha, beta, gamma } = event;

            // Преобразуем углы для всех плоскостей
            planes.forEach((plane, index) => {
                plane.rotation.x = THREE.MathUtils.degToRad(beta);
                plane.rotation.y = THREE.MathUtils.degToRad(gamma);
                plane.rotation.z = THREE.MathUtils.degToRad(alpha);
            });
        }

        // Доступ к данным гироскопа
        if (
            typeof DeviceOrientationEvent !== "undefined" &&
            typeof DeviceOrientationEvent.requestPermission === "function"
        ) {
            DeviceOrientationEvent.requestPermission()
                .then((response) => {
                    if (response === "granted") {
                        window.addEventListener("deviceorientation", updatePlanesWithSensors);
                    } else {
                        document.getElementById("info").textContent = "Permission denied.";
                    }
                })
                .catch(console.error);
        } else if ("DeviceOrientationEvent" in window) {
            window.addEventListener("deviceorientation", updatePlanesWithSensors);
        } else {
            document.getElementById("info").textContent = "DeviceOrientationEvent не поддерживается.";
        }

        // Анимация сцены
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>

