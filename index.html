<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AR Depth Map</title>
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
    <script src="https://cdn.rawgit.com/jeromeetienne/AR.js/2.1.4/aframe/build/aframe-ar.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/depth-estimation@latest/index.js"></script>
  </head>
  <body style="margin: 0">
    <button onclick="toggleCameraAndSensors()" style="position: fixed; top: 10px; left: 10px; z-index: 1000">Toggle Camera and Sensors</button>
    <canvas id="depthCanvas" style="position: absolute; top: 100px; left: 150px; z-index: 1000; display: none; width: 320px; height: 240px;"></canvas>

    <a-scene embedded arjs="sourceType: webcam;">
      <a-entity camera></a-entity>
    </a-scene>

    <script>
      let sensorsActive = false;
      let videoStream;
      let depthEstimator;
      let depthUpdateInterval;
      
      async function toggleCameraAndSensors() {
        sensorsActive = !sensorsActive;
        
        if (sensorsActive) {
          await startCamera();
          await initDepthModel();
          startDepthUpdates();
        } else {
          stopDepthUpdates();
          stopCamera();
        }
      }

      async function startCamera() {
        try {
          videoStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } });
          const video = document.createElement("video");
          video.srcObject = videoStream;
          await video.play();
          document.body.appendChild(video);
        } catch (error) {
          console.error("Ошибка доступа к камере:", error);
        }
      }

      function stopCamera() {
        if (videoStream) {
          videoStream.getTracks().forEach(track => track.stop());
          videoStream = null;
        }
      }

      async function initDepthModel() {
        console.log("Инициализация модели глубины...");
        const model = depthEstimation.SupportedModels.COCODepthEstimation;
        depthEstimator = await depthEstimation.createEstimator(model);
        console.log("Модель глубины инициализирована.");
      }

      function startDepthUpdates() {
        depthUpdateInterval = requestAnimationFrame(updateDepthMap);
        document.getElementById("depthCanvas").style.display = "block";
      }

      function stopDepthUpdates() {
        cancelAnimationFrame(depthUpdateInterval);
        const canvas = document.getElementById("depthCanvas");
        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        canvas.style.display = "none";
      }

      async function updateDepthMap() {
        const video = document.querySelector("video");
        if (depthEstimator && video.readyState === video.HAVE_ENOUGH_DATA) {
          const depthMap = await depthEstimator.estimateDepth(video);

          if (depthMap) {
            const depthData = depthMap.dataSync();
            const canvas = document.getElementById("depthCanvas");
            const ctx = canvas.getContext("2d");
            const width = canvas.width;
            const height = canvas.height;
            const imageData = ctx.createImageData(width, height);

            for (let i = 0; i < depthData.length; i++) {
              const depthValue = Math.floor((1 - depthData[i]) * 255);
              imageData.data[i * 4] = depthValue;
              imageData.data[i * 4 + 1] = 0;
              imageData.data[i * 4 + 2] = 255 - depthValue;
              imageData.data[i * 4 + 3] = 255;
            }
            
            ctx.putImageData(imageData, 0, 0);
          } else {
            console.error("Не удалось получить карту глубины.");
          }
        }
        depthUpdateInterval = requestAnimationFrame(updateDepthMap);
      }
    </script>
  </body>
</html>
